# -*- coding: utf-8 -*-
"""
/***************************************************************************
 DimRedEsg
                                 A QGIS plugin
 Dimensionamento de rede coletora de esgoto...
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2022-07-31
        git sha              : $Format:%H$
        copyright            : (C) 2022 by Alexandre Cavalcante de Oliveira
        email                : alexandre.oliveira@ctec.ufal.br
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import qgis
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction, QFileDialog
from qgis.core import *

# Initialize Qt resources from file resources.py
from .resources import *
# Import the code for the dialog
from .Dim_Rede_Coletora_dialog import DimRedEsgDialog
import os.path
import processing
import sys, os
import pandas as pd
import numpy as np
import math
from osgeo import gdal
from osgeo import ogr
from osgeo import osr
import io
from qgis.utils import iface


class DimRedEsg:
    """QGIS Plugin Implementation."""

    def __init__(self, iface):
        """Constructor.

        :param iface: An interface instance that will be passed to this class
            which provides the hook by which you can manipulate the QGIS
            application at run time.
        :type iface: QgsInterface
        """
        # Save reference to the QGIS interface
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = os.path.dirname(__file__)
        # initialize locale
        locale = QSettings().value('locale/userLocale')[0:2]
        locale_path = os.path.join(
            self.plugin_dir,
            'i18n',
            'DimRedEsg_{}.qm'.format(locale))

        if os.path.exists(locale_path):
            self.translator = QTranslator()
            self.translator.load(locale_path)
            QCoreApplication.installTranslator(self.translator)

        # Declare instance attributes
        self.actions = []
        self.menu = self.tr(u'&Dim. Rede Coletora')

        # Check if plugin was started the first time in current QGIS session
        # Must be set in initGui() to survive plugin reloads
        self.first_start = None

    # noinspection PyMethodMayBeStatic
    def tr(self, message):
        """Get the translation for a string using Qt translation API.

        We implement this ourselves since we do not inherit QObject.

        :param message: String for translation.
        :type message: str, QString

        :returns: Translated version of message.
        :rtype: QString
        """
        # noinspection PyTypeChecker,PyArgumentList,PyCallByClass
        return QCoreApplication.translate('DimRedEsg', message)

    def add_action(
        self,
        icon_path,
        text,
        callback,
        enabled_flag=True,
        add_to_menu=True,
        add_to_toolbar=True,
        status_tip=None,
        whats_this=None,
        parent=None):
        """Add a toolbar icon to the toolbar.

        :param icon_path: Path to the icon for this action. Can be a resource
            path (e.g. ':/plugins/foo/bar.png') or a normal file system path.
        :type icon_path: str

        :param text: Text that should be shown in menu items for this action.
        :type text: str

        :param callback: Function to be called when the action is triggered.
        :type callback: function

        :param enabled_flag: A flag indicating if the action should be enabled
            by default. Defaults to True.
        :type enabled_flag: bool

        :param add_to_menu: Flag indicating whether the action should also
            be added to the menu. Defaults to True.
        :type add_to_menu: bool

        :param add_to_toolbar: Flag indicating whether the action should also
            be added to the toolbar. Defaults to True.
        :type add_to_toolbar: bool

        :param status_tip: Optional text to show in a popup when mouse pointer
            hovers over the action.
        :type status_tip: str

        :param parent: Parent widget for the new action. Defaults None.
        :type parent: QWidget

        :param whats_this: Optional text to show in the status bar when the
            mouse pointer hovers over the action.

        :returns: The action that was created. Note that the action is also
            added to self.actions list.
        :rtype: QAction
        """

        icon = QIcon(icon_path)
        action = QAction(icon, text, parent)
        action.triggered.connect(callback)
        action.setEnabled(enabled_flag)

        if status_tip is not None:
            action.setStatusTip(status_tip)

        if whats_this is not None:
            action.setWhatsThis(whats_this)

        if add_to_toolbar:
            # Adds plugin icon to Plugins toolbar
            self.iface.addToolBarIcon(action)

        if add_to_menu:
            self.iface.addPluginToMenu(
                self.menu,
                action)

        self.actions.append(action)

        return action

    def initGui(self):
        """Create the menu entries and toolbar icons inside the QGIS GUI."""

        icon_path = ':/plugins/Dim_Rede_Coletora/icon.png'
        self.add_action(
            icon_path,
            text=self.tr(u'DimRedEsg'),
            callback=self.run,
            parent=self.iface.mainWindow())

        # will be set False in run()
        self.first_start = True

    def unload(self):
        """Removes the plugin menu item and icon from QGIS GUI."""
        for action in self.actions:
            self.iface.removePluginMenu(
                self.tr(u'&Dim. Rede Coletora'),
                action)
            self.iface.removeToolBarIcon(action)

    def carregaVetor(self):
        # Preenche o combox com as layers vetoriais existentes no projeto
        self.dlg.comboBoxLinha.clear()
        lista_layers = [layer for layer in QgsProject.instance().mapLayers().values()]
        lista_layers_vector = []
        for layer in lista_layers:
            if layer.type() == QgsMapLayer.VectorLayer:
                lista_layers_vector.append(layer.name())
        self.dlg.comboBoxLinha.addItems(lista_layers_vector)

    def carregaRaster(self):
        # Preenche o combox com rasteres existentes no projeto
        self.dlg.comboBoxRaster.clear()
        lista_rasters = [raster for raster in QgsProject.instance().mapLayers().values()]
        lista_layers_raster = []
        for layer in lista_rasters:
            if layer.type() == QgsMapLayer.RasterLayer:
                lista_layers_raster.append(layer.name())
        self.dlg.comboBoxRaster.addItems(lista_layers_raster)

    def vetorEnt(self):
        # Definir vetor definido no combobox
        layerVetor = None
        nomecamada = self.dlg.comboBoxLinha.currentText()
        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == nomecamada:
                layerVetor = lyr
            break
        return layerVetor

    def rasterEnt(self):
        # Definir Raster definido no combobox
        layerRaster = None
        nomecamada = self.dlg.comboBoxRaster.currentText()
        for lyr in QgsProject.instance().mapLayers().values():
            if lyr.name() == nomecamada:
                layerRaster = lyr
            break
        return layerRaster

    def abrirPDF(self):
        import os

        self.plugin_dir = os.path.dirname(__file__)
        qml_path = self.plugin_dir
        # Define o caminho do arquivo PDF a ser aberto
        caminho_arquivo = qml_path + '\Sobre o plugin.pdf'

        # Verifica o sistema operacional
        if os.name == 'nt': # Windows
            os.startfile(caminho_arquivo)
        elif os.name == 'posix': # Mac ou Linux
            os.system('open "{}"'.format(caminho_arquivo))


    def criarCampos(self):
        from PyQt5.QtCore import QVariant
        from qgis.utils import iface
        from qgis.core import QgsProject, QgsDefaultValue
        # Camada:
        nomecamada = self.dlg.comboBoxLinha.currentText()
        layer = QgsProject.instance().mapLayersByName(nomecamada)[0]

        # Cria campos necessários para entradas e saídas (Int)
        camposInt = ['network01', 'aux01', 'aux02', 'auxEE']
        for i in camposInt:
            a = 0
            for j in layer.fields().names():
                if i == j:
                    a = 1
            if a == 0:
                layer.dataProvider().addAttributes([QgsField(i, QVariant.Int)])
        layer.updateFields()

        # Cria campos necessários para entradas e saídas (String)
        camposString = ['Local', 'NomeTrecho']
        for i in camposString:
            a = 0
            for j in layer.fields().names():
                if i == j:
                    a = 1
            if a == 0:
                layer.dataProvider().addAttributes([QgsField(i, QVariant.String, len=200)])
        layer.updateFields()

        # Cria campos necessários para entradas e saídas (Int)
        camposInt = ['auxDiamet']
        for i in camposInt:
            a = 0
            for j in layer.fields().names():
                if i == j:
                    a = 1
            if a == 0:
                layer.dataProvider().addAttributes([QgsField(i, QVariant.Int)])
        layer.updateFields()

        # Cria campos necessários para entradas e saídas (Int)
        camposInt = ['Diametro']
        for i in camposInt:
            a = 0
            for j in layer.fields().names():
                if i == j:
                    a = 1
            if a == 0:
                layer.dataProvider().addAttributes([QgsField(i, QVariant.Int)])
        layer.updateFields()

        # Cria campos necessários para entradas e saídas (Double)
        camposDouble = ['extensao', 'vazaoIP', 'vLinearFP', 'vMontante']
        for i in camposDouble:
            a = 0
            for j in layer.fields().names():
                if i == j:
                    a = 1
            if a == 0:
                layer.dataProvider().addAttributes([QgsField(i, QVariant.Double, len=10, prec=3)])
        layer.updateFields()

        # Cria campos necessários para entradas e saídas (Int)
        camposInt = ['auxTrecho']
        for i in camposInt:
            a = 0
            for j in layer.fields().names():
                if i == j:
                    a = 1
            if a == 0:
                layer.dataProvider().addAttributes([QgsField(i, QVariant.Int)])
        layer.updateFields()

        # Cria campos necessários para entradas e saídas (Double)
        camposDouble = ['vTrecho', 'vTotal', 'vAdotada','CotTerrMon', 'CotTerrJus']
        for i in camposDouble:
            a = 0
            for j in layer.fields().names():
                if i == j:
                    a = 1
            if a == 0:
                layer.dataProvider().addAttributes([QgsField(i, QVariant.Double, len=10, prec=3)])
        layer.updateFields()

        # Cria campos necessários para entradas e saídas (Double)
        camposDouble = ['DecTerreno', 'DecMinima']
        for i in camposDouble:
            a = 0
            for j in layer.fields().names():
                if i == j:
                    a = 1
            if a == 0:
                layer.dataProvider().addAttributes([QgsField(i, QVariant.Double, len=10, prec=4)])
        layer.updateFields()

        # Cria campos necessários para entradas e saídas (Int)
        camposInt = ['auxDecAdot']
        for i in camposInt:
            a = 0
            for j in layer.fields().names():
                if i == j:
                    a = 1
            if a == 0:
                layer.dataProvider().addAttributes([QgsField(i, QVariant.Int)])
        layer.updateFields()

        # Cria campos necessários para entradas e saídas (Double)
        camposDouble = ['DecAdotada']
        for i in camposDouble:
            a = 0
            for j in layer.fields().names():
                if i == j:
                    a = 1
            if a == 0:
                layer.dataProvider().addAttributes([QgsField(i, QVariant.Double, len=10, prec=4)])
        layer.updateFields()

        # Cria campos necessários para entradas e saídas (Double)
        camposDouble = ['CotRedeMon', 'CotRedeJus', 'ProfuPVMon', 'ProfuPVJus', 'TuboQueda', 'LamLiqY_D', 'Velocidade', 'VeloCrit', 'TensaoTrat']
        for i in camposDouble:
            a = 0
            for j in layer.fields().names():
                if i == j:
                    a = 1
            if a == 0:
                layer.dataProvider().addAttributes([QgsField(i, QVariant.Double, len=10, prec=3)])
        layer.updateFields()

    def carregarEstilos(self):
        # Carrega os estilos predefinidos que irão auxiliar no desenvolvimento dos cálculos
        from qgis.core import QgsMapLayerStyle
        from qgis.utils import iface
        import os
        import sys

        # set path to your styles here
        self.plugin_dir = os.path.dirname(__file__)
        qml_path = self.plugin_dir
        # Camada:
        nomecamada = self.dlg.comboBoxLinha.currentText()
        layer = QgsProject.instance().mapLayersByName(nomecamada)[0]
        style_manager = layer.styleManager()

        # read valid style from layer
        style = QgsMapLayerStyle()
        style.readFromLayer(layer)

        listaName = ['linha 01 Diametro.qml', 'linha 02 Extensao.qml', 'linha 03 Lamina (Y_D).qml',
                     'linha 04 Prof PV Jus.qml', 'linha 05 Tensao Trat.qml', 'linha 06 Velocidade.qml',
                     'linha 07 Legenda.qml']
        for Name in listaName:
            # get style name from file
            style_name = Name[:-4]
            # add style with new name
            style_manager.addStyle(style_name, style)
            # set new style as current
            style_manager.setCurrentStyle(style_name)
            # load qml to current style
            success = layer.loadNamedStyle(os.path.join(qml_path, Name))
            if not success:  # if style not loaded remove it
                style_manager.removeStyle(style_name)

    def carregarEstilos1(self):
        # Carrega os estilos predefinidos que irão auxiliar no desenvolvimento dos cálculos
        from qgis.core import QgsMapLayerStyle
        from qgis.utils import iface
        import os
        import sys

        def mensagem(mensagem):
            iface.messageBar().pushMessage("Red_Dim_Esg", mensagem, level=Qgis.Success)

        # set path to your styles here
        self.plugin_dir = os.path.dirname(__file__)
        qml_path = self.plugin_dir
        # Camada:
        nomecamadaL = self.dlg.comboBoxLinha.currentText()
        nomecamadaP = f'{nomecamadaL}_pontos'
        layer = QgsProject.instance().mapLayersByName(nomecamadaP)[0]
        style_manager = layer.styleManager()

        # read valid style from layer
        style = QgsMapLayerStyle()
        style.readFromLayer(layer)

        listaName = ['point 01 ProfMax SL.qml', 'point 02 ProfMax.qml', 'point 03 Tipo.qml',
                     'point 04 TuboQueda.qml', 'point 05 Legenda.qml']
        for Name in listaName:
            # get style name from file
            style_name = Name[:-4]
            # add style with new name
            style_manager.addStyle(style_name, style)
            # set new style as current
            style_manager.setCurrentStyle(style_name)
            # load qml to current style
            success = layer.loadNamedStyle(os.path.join(qml_path, Name))
            if not success:  # if style not loaded remove it
                style_manager.removeStyle(style_name)

        mensagem('Tarefa finalizada!')

    def padraoInicialCampos(self):
        # Aplicar valores padrão para determinados campos
        nomecamada = self.dlg.comboBoxLinha.currentText()
        layer = QgsProject.instance().mapLayersByName(nomecamada)[0]
        camadaRaster = self.dlg.comboBoxRaster.currentText()
        Layer_Raster = QgsProject.instance().mapLayersByName(camadaRaster)[0]

        def mensagemSuccess(mensagem):
            iface.messageBar().pushMessage("Red_Dim_Esg", mensagem, level=Qgis.Success)

        # Atribui ao campo especificado o valor definido na expressão
        exp = 'round(raster_value('+"'"+Layer_Raster.id()+"'"+',1,start_point($geometry)),3)'
        expressao = QgsExpression(exp)
        contexto = QgsExpressionContext()
        contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
        with edit (layer):
            for feat in layer.getFeatures():
                contexto.setFeature(feat)
                feat['CotTerrMon'] = expressao.evaluate(contexto)
                layer.updateFeature(feat)

        exp = 'round(raster_value('+"'"+Layer_Raster.id()+"'"+',1,end_point($geometry)),3)'
        expressao = QgsExpression(exp)
        contexto = QgsExpressionContext()
        contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
        with edit (layer):
            for feat in layer.getFeatures():
                contexto.setFeature(feat)
                feat['CotTerrJus'] = expressao.evaluate(contexto)
                layer.updateFeature(feat)

        exp = 'round($length,2)'
        expressao = QgsExpression(exp)
        contexto = QgsExpressionContext()
        contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
        with edit (layer):
            for feat in layer.getFeatures():
                contexto.setFeature(feat)
                feat['extensao'] = expressao.evaluate(contexto)
                layer.updateFeature(feat)

        exp = 'round(("CotTerrMon"-"CotTerrJus")/"extensao",4)'
        expressao = QgsExpression(exp)
        contexto = QgsExpressionContext()
        contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
        with edit (layer):
            for feat in layer.getFeatures():
                contexto.setFeature(feat)
                feat['DecTerreno'] = expressao.evaluate(contexto)
                layer.updateFeature(feat)

        field_idx = layer.fields().indexOf('auxTrecho')
        new_value = 0
        with edit(layer):
            for feat in layer.getFeatures():
                if feat['auxTrecho'] == None:
                    layer.changeAttributeValue(feat.id(), field_idx, new_value)

        field_idx = layer.fields().indexOf('auxDecAdot')
        new_value = 0
        with edit(layer):
            for feat in layer.getFeatures():
                if feat['auxDecAdot'] == None:
                    layer.changeAttributeValue(feat.id(), field_idx, new_value)

        field_idx = layer.fields().indexOf('auxDiamet')
        new_value = 0
        with edit(layer):
            for feat in layer.getFeatures():
                if feat['auxDiamet'] == None:
                    layer.changeAttributeValue(feat.id(), field_idx, new_value)

        extensao_total = 0
        for feat in layer.getFeatures():
            extensao_total += feat['extensao']

        field_idx = layer.fields().indexOf('vazaoIP')
        new_value = self.dlg.doubleSpinBoxVLIP.value()
        with edit(layer):
            for feat in layer.getFeatures():
                layer.changeAttributeValue(feat.id(), field_idx, new_value)

        field_idx = layer.fields().indexOf('vLinearFP')
        new_value = (self.dlg.doubleSpinBoxVLFP.value()/extensao_total)
        with edit(layer):
            if feat['vLinearFP'] == None:
                for feat in layer.getFeatures():
                    layer.changeAttributeValue(feat.id(), field_idx, new_value)

        field_idx = layer.fields().indexOf('aux01')
        new_value = 0
        with edit(layer):
            for feat in layer.getFeatures():
                if feat['aux01'] == None:
                    layer.changeAttributeValue(feat.id(), field_idx, new_value)

        field_idx = layer.fields().indexOf('aux02')
        new_value = 0
        with edit(layer):
            for feat in layer.getFeatures():
                layer.changeAttributeValue(feat.id(), field_idx, new_value)

        field_idx = layer.fields().indexOf('auxEE')
        new_value = 0
        with edit(layer):
            for feat in layer.getFeatures():
                if feat['auxEE'] == None:
                    layer.changeAttributeValue(feat.id(), field_idx, new_value)

        field_idx = layer.fields().indexOf('Diametro')
        diametro_value = self.dlg.spinBoxDiam.value()
        with edit(layer):
            for feat in layer.getFeatures():
                if feat['auxDiamet'] == 0:
                    layer.changeAttributeValue(feat.id(), field_idx, diametro_value)

        mensagemSuccess('Preparação 01 finalizada!')

    def corrigirSentido(self):
        # Troca o sentido de todos os vetores contidos na lista de entrada
        from PyQt5.QtCore import QVariant
        from qgis.utils import iface
        from qgis.core import QgsProject, QgsDefaultValue, QgsFeatureRequest

        # Camada:
        nomecamada = self.dlg.comboBoxLinha.currentText()
        layer = QgsProject.instance().mapLayersByName(nomecamada)[0]
        def mensagemSuccess(mensagem):
            iface.messageBar().pushMessage("Red_Dim_Esg", mensagem, level=Qgis.Success)

        def mensagemCritical(mensagem):
            iface.messageBar().pushMessage("Red_Dim_Esg", mensagem, level=Qgis.Success)

        def alterarSentido(feat):
            # Troca o sentido de todos os vetores contidos na lista de entrada
            from PyQt5.QtCore import QVariant
            from qgis.utils import iface
            from qgis.core import QgsProject, QgsDefaultValue

            # Camada:
            nomecamada = self.dlg.comboBoxLinha.currentText()
            layer = QgsProject.instance().mapLayersByName(nomecamada)[0]

            geom = feat.geometry()
            vertexI = geom.get()[0][0]
            vertexF = geom.get()[0][-1]
            line = geom.get()[0]
            line[0] = vertexF
            line[1] = vertexI
            with edit (layer):
                geom.reshapeGeometry(line)
                feat.setGeometry(geom)
                layer.updateFeature(feat)

        def toca(feat,P):
            geom = feat.geometry()
            geom = geom.get()[0][P]
            pointGeom = f'POINT({geom.x()} {geom.y()})'
            geom = QgsGeometry.fromWkt(pointGeom)
            # Cria um índice espacial para a camada
            index = QgsSpatialIndex(layer.getFeatures())

            # Encontra todas as geometrias que intersectam com a geometria de interesse
            intersecting_ids = index.intersects(geom.boundingBox())

            # Verifica quais geometrias intersectadas também tocam com a geometria de interesse
            touching_ids = []
            for intersecting_id in intersecting_ids:
                feature = layer.getFeature(intersecting_id)
                if feature.id() != feat.id():
                    touching_ids.append(intersecting_id)
            return touching_ids

        dictFeatures = dict()
        for feat in layer.getFeatures():
            listaIDsIni = toca(feat,0)
            listaIDsFim = toca(feat,-1)
            dictFeatures[feat.id()] = 0,listaIDsIni,listaIDsFim,0

        # Corrigir fim de rede
        # cria um objeto de solicitação de feições
        request = QgsFeatureRequest().setFilterExpression("aux01 = 1")
        for feat1 in layer.getFeatures(request):
            listaIDs = toca(feat1,0)
            listaIDs += toca(feat1,-1)
            for id in listaIDs:
                feat2 = layer.getFeature(id)
                geom1 = feat1.geometry()
                vertex_I1 = geom1.get()[0][0]
                vertex_F1 = geom1.get()[0][-1]
                geom2 = feat2.geometry()
                vertex_I2 = geom2.get()[0][0]
                vertex_F2 = geom2.get()[0][-1]
                if vertex_F1 == vertex_I2 and feat2['aux01'] == 0 or vertex_F1 == vertex_F2 and feat2['aux01'] == 0:
                    alterarSentido(feat1)
                    dictValor = dictFeatures[feat1.id()]
                    dictFeatures[feat1.id()] = 1,dictValor[2],dictValor[1],0
                elif vertex_I1 == vertex_I2 and feat2['aux01'] == 0 or vertex_I1 == vertex_F2 and feat2['aux01'] == 0:
                    dictValor = dictFeatures[feat1.id()]
                    dictFeatures[feat1.id()] = 1,dictValor[1],dictValor[2],0
                elif vertex_I1 == vertex_I2 and feat2['aux01'] == 1 or vertex_I1 == vertex_F2 and feat2['aux01'] == 1:
                    alterarSentido(feat1)
                    dictValor = dictFeatures[feat1.id()]
                    dictFeatures[feat1.id()] = 1,dictValor[2],dictValor[1],0
                elif vertex_F1 == vertex_I2 and feat2['aux01'] == 1 or vertex_F1 == vertex_F2 and feat2['aux01'] == 1:
                    dictValor = dictFeatures[feat1.id()]
                    dictFeatures[feat1.id()] = 1,dictValor[1],dictValor[2],0


        # Correção das demais redes

        dictKeys = [chave for chave, valor in dictFeatures.items() if valor[0] == 1]
        listaIDs = []
        for id in dictKeys:
            listaIDs += dictFeatures[id][1]

        for id in listaIDs:
            if len(listaIDs)>len(dictFeatures):
                break
            controle = 0
            compararIni = dictFeatures[id][1]
            compararFim = dictFeatures[id][2]
            for IniID in compararIni:
                if dictFeatures[IniID][0] == 1 and controle == 0:
                    controle = 1
                    dictValor = dictFeatures[id]
                    dictFeatures[id] = 1,dictValor[2],dictValor[1],1
                    listaIDs += dictValor[2]
            if controle == 0:
                for FimID in compararFim:
                    if dictFeatures[FimID][0] == 1 and controle == 0:
                        controle = 1
                        dictValor = dictFeatures[id]
                        dictFeatures[id] = 1,dictValor[1],dictValor[2],0
                        listaIDs += dictValor[1]
            
        dictKeys = [chave for chave, valor in dictFeatures.items() if valor[3] == 1]
        for ID in dictKeys:
            feat = layer.getFeature(ID)
            alterarSentido(feat)

        mensagemSuccess('Preparação 02 finalizada!')

    def padraoInicialCampos2(self):
            from PyQt5.QtCore import QVariant
            from qgis.utils import iface
            from qgis.core import QgsProject, QgsDefaultValue
            # Aplicar valores padrão para determinados campos
            nomecamada = self.dlg.comboBoxLinha.currentText()
            layer = QgsProject.instance().mapLayersByName(nomecamada)[0]
            camadaRaster = self.dlg.comboBoxRaster.currentText()
            Layer_Raster = QgsProject.instance().mapLayersByName(camadaRaster)[0]

            # Atribui ao campo especificado o valor definido na expressão
            exp = 'round(raster_value('+"'"+Layer_Raster.id()+"'"+',1,start_point($geometry)),3)'
            expressao = QgsExpression(exp)
            contexto = QgsExpressionContext()
            contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
            with edit (layer):
                for feat in layer.getFeatures():
                    contexto.setFeature(feat)
                    feat['CotTerrMon'] = expressao.evaluate(contexto)
                    layer.updateFeature(feat)

            exp = 'round(raster_value('+"'"+Layer_Raster.id()+"'"+',1,end_point($geometry)),3)'
            expressao = QgsExpression(exp)
            contexto = QgsExpressionContext()
            contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
            with edit (layer):
                for feat in layer.getFeatures():
                    contexto.setFeature(feat)
                    feat['CotTerrJus'] = expressao.evaluate(contexto)
                    layer.updateFeature(feat)

            exp = 'round($length,2)'
            expressao = QgsExpression(exp)
            contexto = QgsExpressionContext()
            contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
            with edit (layer):
                for feat in layer.getFeatures():
                    contexto.setFeature(feat)
                    feat['extensao'] = expressao.evaluate(contexto)
                    layer.updateFeature(feat)

            exp = 'round(("CotTerrMon"-"CotTerrJus")/"extensao",4)'
            expressao = QgsExpression(exp)
            contexto = QgsExpressionContext()
            contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
            with edit (layer):
                for feat in layer.getFeatures():
                    contexto.setFeature(feat)
                    feat['DecTerreno'] = expressao.evaluate(contexto)
                    layer.updateFeature(feat)

    def atribuirVazoes(self):
        # Calcula e atribue vazões
        from PyQt5.QtCore import QVariant
        from qgis.utils import iface
        from qgis.core import QgsProject, QgsDefaultValue

        # Camada:
        nomecamada = self.dlg.comboBoxLinha.currentText()
        layer = QgsProject.instance().mapLayersByName(nomecamada)[0]

        def toca(feat,P):
            geom = feat.geometry()
            geom = geom.get()[0][P]
            pointGeom = f'POINT({geom.x()} {geom.y()})'
            geom = QgsGeometry.fromWkt(pointGeom)
            # Cria um índice espacial para a camada
            index = QgsSpatialIndex(layer.getFeatures())

            # Encontra todas as geometrias que intersectam com a geometria de interesse
            intersecting_ids = index.intersects(geom.boundingBox())

            # Verifica quais geometrias intersectadas também tocam com a geometria de interesse
            touching_ids = []
            for intersecting_id in intersecting_ids:
                feature = layer.getFeature(intersecting_id)
                if feature.id() != feat.id():
                    touching_ids.append(intersecting_id)
            return touching_ids

        dictFeatures = dict()
        for feat in layer.getFeatures():
            listaIDsIni = toca(feat,0)
            listaIDsFim = toca(feat,-1)
            dictFeatures[feat.id()] = listaIDsIni,listaIDsFim,0,0,0,0,0,0

        # Vazões das redes PS
        for feat in layer.getFeatures():
            if feat['aux02'] == 1:
                dictValor = dictFeatures[feat.id()]
                dictFeatures[feat.id()] = dictValor[0],dictValor[1],0,0,0,1,0,0

        for feat in layer.getFeatures():
            if feat['auxTrecho'] == 0 and feat['auxEE'] == 0:
                new_value = feat['vLinearFP'] * feat['extensao']
                dictValor = dictFeatures[feat.id()]
                dictFeatures[feat.id()] = dictValor[0],dictValor[1],dictValor[2],new_value,dictValor[4],dictValor[5],dictValor[6],dictValor[7]

        for feat in layer.getFeatures():
            if feat['auxTrecho'] == 1 and feat['auxEE'] == 0:
                new_value = feat['vTrecho']
                dictValor = dictFeatures[feat.id()]
                dictFeatures[feat.id()] = dictValor[0],dictValor[1],dictValor[2],new_value,dictValor[4],dictValor[5],dictValor[6],dictValor[7]

        for feat in layer.getFeatures():
            if feat['aux01'] == 1:
                dictValor = dictFeatures[feat.id()]
                dictFeatures[feat.id()] = dictValor[0],dictValor[1],dictValor[2],dictValor[3],dictValor[4],dictValor[5],1,dictValor[7]

        # Atribuição das vazões dos demais trechos

        dictKeys = [chave for chave, valor in dictFeatures.items() if valor[5] == 1]
        listaIDs = dictKeys
            
        for id in listaIDs:
            if len(listaIDs)>len(dictFeatures):
                break
            somaVmon = 0
            somaVtot = 0
            somaControl = 0
            guardarID = []
            compararIni = dictFeatures[id][0]
            compararFim = dictFeatures[id][1]
            for IniID in compararIni:
                somaVmon += dictFeatures[IniID][4]
            dictValor = dictFeatures[id]
            somaVtot = somaVmon + dictValor[3]
            dictFeatures[id] = dictValor[0],dictValor[1],somaVmon,dictValor[3],somaVtot,1,dictValor[6],dictValor[7]

            for FimID in compararFim:
                dictValor = dictFeatures[FimID]
                somaControl += dictValor[5]
                if dictValor[5] == 0:
                    guardarID += [FimID]
            if somaControl == (len(compararFim) - 1):
                for i in guardarID:
                    if i not in listaIDs and dictFeatures[id][6] == 0:
                        listaIDs += [i]

        # Passar valores do dicionário para tabela de atributos
        for feat in layer.getFeatures():
            dictValor = dictFeatures[feat.id()]
            field_id1 = layer.fields().indexOf('vMontante')
            field_id2 = layer.fields().indexOf('vTrecho')
            field_id3 = layer.fields().indexOf('vTotal')
            new_value1 = dictValor[2]
            new_value2 = dictValor[3]
            new_value3 = dictValor[4]
            with edit(layer):
                layer.changeAttributeValue(feat.id(), field_id1, new_value1)
                layer.changeAttributeValue(feat.id(), field_id2, new_value2)
                layer.changeAttributeValue(feat.id(), field_id3, new_value3)

        for feat in layer.getFeatures():
            field_idx = layer.fields().indexOf('vAdotada')
            lista01 = []
            lista01 += [feat['vTotal'], self.dlg.doubleSpinBoxVP.value()]
            new_value = max(lista01)
            with edit(layer):
                layer.changeAttributeValue(feat.id(), field_idx, new_value)

    def conectividade(self):
        from PyQt5.QtCore import QVariant
        from qgis.core import QgsProject
        # Calcula a declividade mínima das redes
        nomecamada = self.dlg.comboBoxLinha.currentText()
        layer = QgsProject.instance().mapLayersByName(nomecamada)[0]

        # Retorna redes conectadas
        def toca(feat,P):
            geom = feat.geometry()
            geom = geom.get()[0][P]
            pointGeom = f'POINT({geom.x()} {geom.y()})'
            geom = QgsGeometry.fromWkt(pointGeom)
            # Cria um índice espacial para a camada
            index = QgsSpatialIndex(layer.getFeatures())

            # Encontra todas as geometrias que intersectam com a geometria de interesse
            intersecting_ids = index.intersects(geom.boundingBox())

            # Verifica quais geometrias intersectadas também tocam com a geometria de interesse
            touching_ids = []
            for intersecting_id in intersecting_ids:
                feature = layer.getFeature(intersecting_id)
                if feature.id() != feat.id():
                    touching_ids.append(intersecting_id)
            return touching_ids

        # atribue '0' à network e cria dicionário de feições
        dictFeatures = dict()
        exp = '0'
        expressao = QgsExpression(exp)
        contexto = QgsExpressionContext()
        contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
        with edit (layer):
            for feat in layer.getFeatures():
                listaIDsIni = toca(feat,0)
                listaIDsFim = toca(feat,-1)
                dictFeatures[feat.id()] = listaIDsIni,listaIDsFim,0
                contexto.setFeature(feat)
                feat['network01'] = expressao.evaluate(contexto)
                layer.updateFeature(feat)

        # atribui valor por conectividade
        dictKeys = [chave for chave, valor in dictFeatures.items() if valor[2] == 0]
        a = 1
        lista = []
        while len(dictKeys)>0:
            id1 = dictKeys[0]
            lista = [id1]
            for id2 in lista:
                dictValor = dictFeatures[id2]
                dictFeatures[id2] = dictValor[0],dictValor[1],a
                IniID = dictValor[0]
                FimID = dictValor[1]
                for i in IniID:
                    dictValorIni = dictFeatures[i]
                    if (id2 in dictValorIni[0]) or (id2 in dictValorIni[1]):
                        dictFeatures[i] = dictValorIni[0],dictValorIni[1],a
                        if i not in lista:
                            lista += [i]
                for i in FimID:
                    dictValorFim = dictFeatures[i]
                    if (id2 in dictValorFim[0]) or (id2 in dictValorFim[1]):
                        dictFeatures[i] = dictValorFim[0],dictValorFim[1],a
                        if i not in lista:
                            lista += [i]
            dictKeys = [chave for chave, valor in dictFeatures.items() if valor[2] == 0]
            a += 1

        for feat in layer.getFeatures():
            dictValor = dictFeatures[feat.id()]
            field_id1 = layer.fields().indexOf('network01')
            new_value1 = dictValor[2]
            with edit(layer):
                layer.changeAttributeValue(feat.id(), field_id1, new_value1)

    def DecMinima(self):
        from PyQt5.QtCore import QVariant
        from qgis.utils import iface
        from qgis.core import QgsProject, QgsDefaultValue
        import math
        # Calcula a declividade mínima das redes
        nomecamada = self.dlg.comboBoxLinha.currentText()
        layer = QgsProject.instance().mapLayersByName(nomecamada)[0]

        field_idx = layer.fields().indexOf('DecMinima')
        with edit(layer):
            for feat in layer.getFeatures():
                decMinima = 0.0055*(feat['vazaoIP']**(-0.47))
                layer.changeAttributeValue(feat.id(), field_idx, decMinima)

    def identificarPS2(self):
        # Troca o sentido de todos os vetores contidos na lista de entrada
        from PyQt5.QtCore import QVariant
        from qgis.utils import iface
        from qgis.core import QgsProject, QgsDefaultValue
        
        # Camada:
        nomecamada = self.dlg.comboBoxLinha.currentText()
        layer = QgsProject.instance().mapLayersByName(nomecamada)[0]

        def toca(feat,P):
            geom = feat.geometry()
            geom = geom.get()[0][P]
            pointGeom = f'POINT({geom.x()} {geom.y()})'
            geom = QgsGeometry.fromWkt(pointGeom)
            # Cria um índice espacial para a camada
            index = QgsSpatialIndex(layer.getFeatures())

            # Encontra todas as geometrias que intersectam com a geometria de interesse
            intersecting_ids = index.intersects(geom.boundingBox())

            # Verifica quais geometrias intersectadas também tocam com a geometria de interesse
            touching_ids = []
            for intersecting_id in intersecting_ids:
                feature = layer.getFeature(intersecting_id)
                if feature.id() != feat.id():
                    touching_ids.append(intersecting_id)
            return touching_ids

        # Identifica todos os trechos Ponta Seca (PS)
        for feat in layer.getFeatures():
            listaIDsIni = toca(feat,0)
            if len(listaIDsIni) == 0:
                field_idx = layer.fields().indexOf('aux02')
                new_value = 1
                with edit(layer):
                    layer.changeAttributeValue(feat.id(), field_idx, new_value)
            elif len(listaIDsIni) > 0:
                field_idx = layer.fields().indexOf('aux02')
                new_value = 0
                with edit(layer):
                    layer.changeAttributeValue(feat.id(), field_idx, new_value)

    def DecProfRedes(self):
        from PyQt5.QtCore import QVariant
        from qgis.utils import iface
        from qgis.core import QgsProject, QgsDefaultValue
        import math
        # Calcula as declividades e profundidades das redes
        nomecamada = self.dlg.comboBoxLinha.currentText()
        layer = QgsProject.instance().mapLayersByName(nomecamada)[0]
        recobrimentoMin = self.dlg.doubleSpinBoxRM.value()

        def toca(feat,P):
            geom = feat.geometry()
            geom = geom.get()[0][P]
            pointGeom = f'POINT({geom.x()} {geom.y()})'
            geom = QgsGeometry.fromWkt(pointGeom)
            # Cria um índice espacial para a camada
            index = QgsSpatialIndex(layer.getFeatures())

            # Encontra todas as geometrias que intersectam com a geometria de interesse
            intersecting_ids = index.intersects(geom.boundingBox())

            # Verifica quais geometrias intersectadas também tocam com a geometria de interesse
            touching_ids = []
            for intersecting_id in intersecting_ids:
                feature = layer.getFeature(intersecting_id)
                if feature.id() != feat.id():
                    touching_ids.append(intersecting_id)
            return touching_ids

        dictFeatures = dict()
        for feat in layer.getFeatures():
            geom = feat.geometry()
            vertexI = geom.get()[0][0]
            vertexF = geom.get()[0][-1]
            listaIDsIni = toca(feat,0)
            listaIDsFim = toca(feat,-1)
            dictFeatures[feat.id()] = listaIDsIni,listaIDsFim,vertexI,vertexF,0,0,0,0

        dictKeys = [chave for chave, valor in dictFeatures.items() if len(valor[0]) == 0]
        listaIDs = dictKeys
            
        for id in listaIDs:
            dictValor1 = dictFeatures[id]
            feat = layer.getFeature(id)
            if len(listaIDs)>len(dictFeatures):
                break
            controle = 0
            guardarID = []
            compararIni = dictValor1[0]
            compararFim = dictValor1[1]
            #definir CotRedeMon
            if len(compararIni) == 0:
                CotRedeMon = (feat['CotTerrMon'] - recobrimentoMin)
            elif len(compararIni) > 0:
                listaCota = []
                for IniID in compararIni:
                    listaCota += [dictFeatures[IniID][6]]
                CotRedeMon = min(listaCota)
                
            #definir CotRedeJus
            if feat['auxEE'] == 0 and feat['auxDecAdot'] == 1: 
                DecAdotada = feat['DecAdotada']
                CotRedeJus = (CotRedeMon - (feat['extensao']*DecAdotada))
            elif feat['auxEE'] == 0 and feat['auxDecAdot'] == 0:
                if (CotRedeMon - (feat['extensao']*feat['DecMinima'])) <= (feat['CotTerrJus'] - recobrimentoMin):
                    DecAdotada = feat['DecMinima']
                    CotRedeJus = (CotRedeMon - (feat['extensao']*DecAdotada))
                elif (CotRedeMon - (feat['extensao']*feat['DecMinima'])) > (feat['CotTerrJus'] - recobrimentoMin):
                    DecAdotada = ((CotRedeMon - (feat['CotTerrJus'] - recobrimentoMin)) / feat['extensao'])
                    CotRedeJus = (CotRedeMon - (feat['extensao']*DecAdotada))
            elif feat['auxEE'] == 1:
                CotRedeJus = (feat['CotTerrJus'] - recobrimentoMin)
                DecAdotada = ((CotRedeMon - CotRedeJus)/ feat['extensao'])

            dictFeatures[id] = dictValor1[0],dictValor1[1],dictValor1[2],dictValor1[3],DecAdotada,CotRedeMon,CotRedeJus,1
            dictValor1 = dictFeatures[id]

            for FimID in compararFim:
                dictValor2 = dictFeatures[FimID]
                if dictValor2[7] == 0 and dictValor2[3] == dictValor1[3]:
                    controle = 1
                if dictValor2[2] == dictValor1[3]:
                    guardarID += [FimID]
            if len(dictValor1[1]) == 1:
                for i in guardarID:
                    if i not in listaIDs:
                        listaIDs += [i]
            elif controle != 1:
                for i in guardarID:
                    if i not in listaIDs:
                        listaIDs += [i]

                        
        # Passar valores do dicionário para tabela de atributos
        for feat in layer.getFeatures():
            dictValor = dictFeatures[feat.id()]
            field_id1 = layer.fields().indexOf('DecAdotada')
            field_id2 = layer.fields().indexOf('CotRedeMon')
            field_id3 = layer.fields().indexOf('CotRedeJus')
            new_value1 = dictValor[4]
            new_value2 = dictValor[5]
            new_value3 = dictValor[6]
            with edit(layer):
                layer.changeAttributeValue(feat.id(), field_id1, new_value1)
                layer.changeAttributeValue(feat.id(), field_id2, new_value2)
                layer.changeAttributeValue(feat.id(), field_id3, new_value3)

    def ProfPV(self):
        from PyQt5.QtCore import QVariant
        from qgis.utils import iface
        from qgis.core import QgsProject, QgsDefaultValue
        import math
        # Calcula a profundidade dos PVs
        nomecamada = self.dlg.comboBoxLinha.currentText()
        layer = QgsProject.instance().mapLayersByName(nomecamada)[0]

        exp = '"CotTerrMon" - "CotRedeMon"'
        expressao = QgsExpression(exp)
        contexto = QgsExpressionContext()
        contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
        with edit (layer):
            for feat in layer.getFeatures():
                contexto.setFeature(feat)
                feat['ProfuPVMon'] = expressao.evaluate(contexto)
                layer.updateFeature(feat)

        exp = '"CotTerrJus" - "CotRedeJus"'
        expressao = QgsExpression(exp)
        contexto = QgsExpressionContext()
        contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
        with edit (layer):
            for feat in layer.getFeatures():
                contexto.setFeature(feat)
                feat['ProfuPVJus'] = expressao.evaluate(contexto)
                layer.updateFeature(feat)

    def tuboQueda(self):
        from PyQt5.QtCore import QVariant
        from qgis.utils import iface
        from qgis.core import QgsProject, QgsDefaultValue
        import math
        # Calcula as declividades e profundidades das redes
        nomecamada = self.dlg.comboBoxLinha.currentText()
        layer = QgsProject.instance().mapLayersByName(nomecamada)[0]

        def toca(feat,P):
            geom = feat.geometry()
            geom = geom.get()[0][P]
            pointGeom = f'POINT({geom.x()} {geom.y()})'
            geom = QgsGeometry.fromWkt(pointGeom)
            # Cria um índice espacial para a camada
            index = QgsSpatialIndex(layer.getFeatures())

            # Encontra todas as geometrias que intersectam com a geometria de interesse
            intersecting_ids = index.intersects(geom.boundingBox())

            # Verifica quais geometrias intersectadas também tocam com a geometria de interesse
            touching_ids = []
            for intersecting_id in intersecting_ids:
                feature = layer.getFeature(intersecting_id)
                if feature.id() != feat.id():
                    touching_ids.append(intersecting_id)
            return touching_ids

        dictFeatures = dict()
        for feat in layer.getFeatures():
            geom = feat.geometry()
            vertex_I = geom.get()[0][0]
            vertex_F = geom.get()[0][-1]
            listaIDsIni = toca(feat,0)
            listaIDsFim = toca(feat,-1)
            dictFeatures[feat.id()] = listaIDsIni,listaIDsFim,feat['ProfuPVMon'],feat['ProfuPVJus'],vertex_I,vertex_F

        # Calculo da altura do tubo de queda
        for id in dictFeatures:
            feat = layer.getFeature(id)
            if feat['aux01'] == 0:
                compararFim = dictFeatures[id][1]
                dictValor1 = dictFeatures[id]
                for id2 in compararFim:
                    dictValor2 = dictFeatures[id2]
                    if (dictValor2[2] - dictValor1[3]) >= 0.5 and (dictValor2[4] == dictValor1[5]):
                        altura = (dictValor2[2] - dictValor1[3])
                        field_idx = layer.fields().indexOf('TuboQueda')
                        with edit(layer):
                            layer.changeAttributeValue(feat.id(), field_idx, altura)
                            #layer.updateFeature(feat)
                    elif (dictValor2[2] - dictValor1[3]) < 0.5 and (dictValor2[4] == dictValor1[5]):
                        altura = 0
                        field_idx = layer.fields().indexOf('TuboQueda')
                        with edit(layer):
                            layer.changeAttributeValue(feat.id(), field_idx, altura)
                            #layer.updateFeature(feat)
            else:
                altura = 0
                field_idx = layer.fields().indexOf('TuboQueda')
                with edit(layer):
                    layer.changeAttributeValue(feat.id(), field_idx, altura)
                    #layer.updateFeature(feat)


    def indicadores(self):
        #Calcula os indicadores e, se necessario, aumenta o diâmetro da rede
        from PyQt5.QtCore import QVariant
        from qgis.utils import iface
        from qgis.core import QgsProject, QgsDefaultValue

        # Camada
        nomecamada = self.dlg.comboBoxLinha.currentText()
        layer = QgsProject.instance().mapLayersByName(nomecamada)[0]
        def mensagem(mensagem):
            iface.messageBar().pushMessage("Red_Dim_Esg", mensagem, level=Qgis.Success)

        import pandas as pd
        self.plugin_dir = os.path.dirname(__file__)
        caminho_para_pasta = self.plugin_dir
        caminho_para_arquivo = '/tabelaDim.txt'
        df = pd.read_csv(f'{caminho_para_pasta}{caminho_para_arquivo}', sep=';', encoding="utf-8", index_col=None)
        df = df.applymap(lambda x: float(x.replace(',', '.')))
        df.set_index('Altura de agua', inplace=True)

        mensagem('início')
        # Calcula Y/D
        def calc_YD(feat):
            Qp = 24 * ((feat['Diametro']/1000)**(8/3))*(feat['DecAdotada']**(1/2))*1000
            try:
                q_Qp = feat['vAdotada']/Qp
            except ZeroDivisionError:
                q_Qp = 2
            if q_Qp <= 0.45:
                Y_D = (14.308*q_Qp**3) - (8.8566*q_Qp**2) + (2.5157*q_Qp) + 0.0411
            elif q_Qp > 0.45:
                Y_D = (0.3761*q_Qp**3) - (0.6581*q_Qp**2) + (0.9591*q_Qp) + 0.1363
            return Y_D

        # Verifica e atribui Y/D
        for feat in layer.getFeatures():
            if feat['auxEE'] == 0:
                mudarDiam = 1
                while mudarDiam == 1:
                    Y_D = calc_YD(feat)
                    if Y_D < 0 or Y_D > 0.75:
                        mudarDiam = 1
                    elif Y_D >= 0 and Y_D <= 0.75:
                        mudarDiam = 0
                        exp = str(Y_D)
                        expressao = QgsExpression(exp)
                        contexto = QgsExpressionContext()
                        contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
                        with edit (layer):
                            contexto.setFeature(feat)
                            feat['LamLiqY_D'] = expressao.evaluate(contexto)
                            layer.updateFeature(feat)
                    if feat['Diametro'] > 5000 or feat['auxDiamet'] == 1:
                        mudarDiam = 0
                    if mudarDiam == 1:
                        exp = '"Diametro" + 50'
                        expressao = QgsExpression(exp)
                        contexto = QgsExpressionContext()
                        contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
                        with edit (layer):
                            contexto.setFeature(feat)
                            feat['Diametro'] = expressao.evaluate(contexto)
                            layer.updateFeature(feat)
            elif feat['auxEE'] == 1:
                field_id1 = layer.fields().indexOf('LamLiqY_D')
                field_id2 = layer.fields().indexOf('Velocidade')
                field_id3 = layer.fields().indexOf('VeloCrit')
                field_id4 = layer.fields().indexOf('TensaoTrat')
                new_value1 = 0
                new_value2 = 0
                new_value3 = 0
                new_value4 = 0
                with edit(layer):
                    layer.changeAttributeValue(feat.id(), field_id1, new_value1)
                    layer.changeAttributeValue(feat.id(), field_id2, new_value2)
                    layer.changeAttributeValue(feat.id(), field_id3, new_value3)
                    layer.changeAttributeValue(feat.id(), field_id4, new_value4)

        # Calcula Z2, Z3, Z4, Z5, Z6
        def calc_Z(feat,df):
      
            def find_closest(lst, x):
                import bisect
                index = bisect.bisect_left(lst, x)
                if index == 0:
                    return lst[0], lst[1]
                if index == len(lst):
                    return lst[-2], lst[-1]
                before = lst[index - 1]
                after = lst[index]
                return before, after

            alturaAgua = 2 * feat['LamLiqY_D']
            valorIndex = find_closest(df.index, alturaAgua)
            Z2 = ((alturaAgua - valorIndex[0])/0.05) * (df['Secao molhada'][valorIndex[1]] - df['Secao molhada'][valorIndex[0]]) + df['Secao molhada'][valorIndex[0]]
            Z3 = ((alturaAgua - valorIndex[0])/0.05) * (df['Perimetro molhado'][valorIndex[1]] - df['Perimetro molhado'][valorIndex[0]]) + df['Perimetro molhado'][valorIndex[0]]
            Z4 = ((alturaAgua - valorIndex[0])/0.05) * (df['Raio hidraulico'][valorIndex[1]] - df['Raio hidraulico'][valorIndex[0]]) + df['Raio hidraulico'][valorIndex[0]]
            Z5 = ((alturaAgua - valorIndex[0])/0.05) * (df['Velocidade'][valorIndex[1]] - df['Velocidade'][valorIndex[0]]) + df['Velocidade'][valorIndex[0]]
            Z6 = ((alturaAgua - valorIndex[0])/0.05) * (df['Vazao'][valorIndex[1]] - df['Vazao'][valorIndex[0]]) + df['Vazao'][valorIndex[0]]
            return Z2, Z3, Z4, Z5, Z6

        # Calcula Velocidade do fluido
        def calc_Velo(feat, Z4, Z5):
            Raio = (feat['Diametro']/2000)
            incli = feat['DecAdotada']
            Rh = Raio * Z4
            coefManing = self.dlg.doubleSpinBoxCoef.value()
            C = (Rh**(1/6))/coefManing
            velocidade = Z5*C*((Raio*incli)**(1/2))
            return velocidade
        
        # Calcula Velocidade Crítica do fluido
        def calc_VeloCrit(feat, Z4):
            Rh = Z4 * (feat['Diametro']/2000)
            gravidade = self.dlg.doubleSpinBoxGrav.value()
            vCrit = 6 * Rh * gravidade
            return vCrit

        # Calcula Velocidade Crítica do fluido
        def calc_TensaoT(feat, Z4):
            Rh = Z4 * (feat['Diametro']/2000)
            incli = feat['DecAdotada']
            tensaoT = (10**4) * Rh * incli
            return tensaoT

        # Verifica e atribui Velocidade e Velocidade Crítica
        for feat in layer.getFeatures():
            if feat['auxEE'] == 0:
                Z = calc_Z(feat,df)
                #Z2 = Z[0]
                #Z3 = Z[1]
                Z4 = Z[2]
                Z5 = Z[3]
                #Z6 = Z[4]
                tensaoT = calc_TensaoT(feat, Z4)
                exp = str(tensaoT)
                expressao = QgsExpression(exp)
                contexto = QgsExpressionContext()
                contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
                with edit (layer):
                    contexto.setFeature(feat)
                    feat['TensaoTrat'] = expressao.evaluate(contexto)
                    layer.updateFeature(feat)
                mudarDiam = 1
                while mudarDiam == 1:
                    Velo = calc_Velo(feat, Z4, Z5)
                    VeloCrit = calc_VeloCrit(feat, Z4)
                    if (feat['LamLiqY_D'] > 0.5) and (Velo > VeloCrit):
                        mudarDiam = 1
                    elif feat['LamLiqY_D'] <= 0.75 :
                        mudarDiam = 0
                        exp = str(Velo)
                        expressao = QgsExpression(exp)
                        contexto = QgsExpressionContext()
                        contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
                        with edit (layer):
                            contexto.setFeature(feat)
                            feat['Velocidade'] = expressao.evaluate(contexto)
                            layer.updateFeature(feat)
                        exp = str(VeloCrit)
                        expressao = QgsExpression(exp)
                        contexto = QgsExpressionContext()
                        contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
                        with edit (layer):
                            contexto.setFeature(feat)
                            feat['VeloCrit'] = expressao.evaluate(contexto)
                            layer.updateFeature(feat)
                    if feat['Diametro'] > 10000 or feat['auxDiamet'] == 1:
                        mudarDiam = 0
                    if mudarDiam == 1:
                        exp = '"Diametro" + 50'
                        expressao = QgsExpression(exp)
                        contexto = QgsExpressionContext()
                        contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
                        with edit (layer):
                            contexto.setFeature(feat)
                            feat['Diametro'] = expressao.evaluate(contexto)
                            layer.updateFeature(feat)
                        New_YD = calc_YD(feat)
                        exp = str(New_YD)
                        expressao = QgsExpression(exp)
                        contexto = QgsExpressionContext()
                        contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))
                        with edit (layer):
                            contexto.setFeature(feat)
                            feat['LamLiqY_D'] = expressao.evaluate(contexto)
        mensagem('Dimensionamento finalizado!')

    def CriarPV(self):
        # Cria Shape Temporário de pontos
        from PyQt5.QtCore import QVariant
        from qgis.utils import iface
        from qgis.core import QgsProject, QgsDefaultValue, QgsVectorLayer, QgsFeature, QgsGeometry
        import os

        # Carregue seu shapefile de linhas
        nomecamada = self.dlg.comboBoxLinha.currentText()
        layer = QgsProject.instance().mapLayersByName(nomecamada)[0]

        # Crie o novo shapefile de pontos
        aa1 = 1
        project = QgsProject.instance()
        layersALL = project.mapLayers().values()
        for layerTeste in layersALL:
            if layerTeste.name() == f'{nomecamada}_pontos':
                aa1 = 0
                point_layer = layerTeste
        if aa1 == 1:
            crs = layer.crs()
            point_layer = QgsVectorLayer("Point?crs=" + crs.toWkt(), f'{nomecamada}_pontos', "memory")
            prov = point_layer.dataProvider()
            prov.addAttributes([QgsField("id", QVariant.Int)])
            point_layer.updateFields()

            # Extrair pontos de início e fim de cada linha
            features = layer.getFeatures()
            for feature in features:
                geom1 = feature.geometry()
                vertex_I1 = geom1.get()[0][0]
                vertex_F1 = geom1.get()[0][-1]
                start_point = QgsPointXY(vertex_I1.x(),vertex_I1.y())
                end_point = QgsPointXY(vertex_F1.x(),vertex_F1.y())
                
                # Adicione os pontos ao novo shapefile de pontos
                geoms = []
                feat = QgsFeature()
                feat.setGeometry(QgsGeometry.fromPointXY(start_point))
                prov.addFeatures([feat])
                
                feat = QgsFeature()
                feat.setGeometry(QgsGeometry.fromPointXY(end_point))
                prov.addFeatures([feat])

            # Adicione o novo shapefile de pontos ao projeto do QGIS
            QgsProject.instance().addMapLayer(point_layer)

        # Cria campos necessários para entradas e saídas (String)
        camposString = ['Tipo', 'Nome']
        for i in camposString:
            a = 0
            for j in point_layer.fields().names():
                if i == j:
                    a = 1
            if a == 0:
                point_layer.dataProvider().addAttributes([QgsField(i, QVariant.String)])
        point_layer.updateFields()

        # Cria campos necessários para entradas e saídas (Int)
        camposInt = ['NumTubos', 'TuboQueda']
        for i in camposInt:
            a = 0
            for j in point_layer.fields().names():
                if i == j:
                    a = 1
            if a == 0:
                point_layer.dataProvider().addAttributes([QgsField(i, QVariant.Int)])
        point_layer.updateFields()

        # Cria campos necessários para entradas e saídas (Double)
        camposDouble = ['ProfMaxPV', 'CotaTerre']
        for i in camposDouble:
            a = 0
            for j in point_layer.fields().names():
                if i == j:
                    a = 1
            if a == 0:
                point_layer.dataProvider().addAttributes([QgsField(i, QVariant.Double, len=10, prec=3)])
        point_layer.updateFields()

        #Apagar geometrias duplicadas
        # Cria uma lista para armazenar as geometrias das feições
        geoms = []

        # Itera sobre as feições
        for feature in point_layer.getFeatures():
            geom = str(feature.geometry())
            if geom in geoms:
                point_layer.startEditing()
                point_layer.deleteFeature(feature.id())
                point_layer.commitChanges()
            else:
                geoms.append(geom)

    def calc_PV(self):
        from PyQt5.QtCore import QVariant
        from qgis.utils import iface
        from qgis.core import QgsProject, QgsDefaultValue

        # Camada
        camadaRaster = self.dlg.comboBoxRaster.currentText()
        Layer_Raster = QgsProject.instance().mapLayersByName(camadaRaster)[0]
        nomecamadaL = self.dlg.comboBoxLinha.currentText()
        nomecamadaP = f'{nomecamadaL}_pontos'
        layerP = QgsProject.instance().mapLayersByName(nomecamadaP)[0]
        layerL = QgsProject.instance().mapLayersByName(nomecamadaL)[0]

        for feat1 in layerP.getFeatures():
            geom1 = feat1.geometry()
            vertex_point = geom1.get()
            for feat2 in layerL.getFeatures():
                geom2 = feat2.geometry()
                vertex_I2 = geom2.get()[0][0]
                vertex_F2 = geom2.get()[0][-1]
                if vertex_point == vertex_I2 and feat2['auxEE'] == 1 or vertex_point == vertex_F2 and feat2['auxEE'] == 1:
                    exp = '\'EE\''
                    expressao = QgsExpression(exp)
                    contexto = QgsExpressionContext()
                    contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layerP))
                    with edit (layerP):
                        contexto.setFeature(feat1)
                        feat1['Tipo'] = expressao.evaluate(contexto)
                        layerP.updateFeature(feat1)
                elif vertex_point == vertex_I2 and feat2['aux02'] == 1:
                    exp = '\'TL\''
                    expressao = QgsExpression(exp)
                    contexto = QgsExpressionContext()
                    contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layerP))
                    with edit (layerP):
                        contexto.setFeature(feat1)
                        feat1['Tipo'] = expressao.evaluate(contexto)
                        layerP.updateFeature(feat1)
                elif vertex_point == vertex_I2 and feat2['aux02'] == 0 or vertex_point == vertex_F2 and feat2['aux02'] == 0:
                    exp = '\'PV\''
                    expressao = QgsExpression(exp)
                    contexto = QgsExpressionContext()
                    contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layerP))
                    with edit (layerP):
                        contexto.setFeature(feat1)
                        feat1['Tipo'] = expressao.evaluate(contexto)
                        layerP.updateFeature(feat1)
        exp = '"Tipo" || $id'
        expressao = QgsExpression(exp)
        contexto = QgsExpressionContext()
        contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layerP))
        with edit (layerP):
            for feat in layerP.getFeatures():
                contexto.setFeature(feat)
                feat['Nome'] = expressao.evaluate(contexto)
                layerP.updateFeature(feat)

        exp = '0'
        expressao = QgsExpression(exp)
        contexto = QgsExpressionContext()
        contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layerP))
        with edit (layerP):
            for feat in layerP.getFeatures():
                contexto.setFeature(feat)
                feat['ProfMaxPV'] = expressao.evaluate(contexto)
                layerP.updateFeature(feat)
                
        exp = '0'
        expressao = QgsExpression(exp)
        contexto = QgsExpressionContext()
        contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layerP))
        with edit (layerP):
            for feat in layerP.getFeatures():
                contexto.setFeature(feat)
                feat['TuboQueda'] = expressao.evaluate(contexto)
                layerP.updateFeature(feat)

        # Atribui ao campo especificado o valor definido na expressão
        exp = 'round(raster_value('+"'"+Layer_Raster.id()+"'"+',1, $geometry),3)'
        expressao = QgsExpression(exp)
        contexto = QgsExpressionContext()
        contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layerP))
        with edit (layerP):
            for feat in layerP.getFeatures():
                contexto.setFeature(feat)
                feat['CotaTerre'] = expressao.evaluate(contexto)
                layerP.updateFeature(feat)

        for feat1 in layerP.getFeatures():
            contRede = 0
            auxCont = 0
            geom1 = feat1.geometry()
            vertex_point = geom1.get()
            for feat2 in layerL.getFeatures():
                geom2 = feat2.geometry()
                vertex_I2 = geom2.get()[0][0]
                vertex_F2 = geom2.get()[0][-1]
                if feat1['Tipo'] == 'TL' and vertex_I2 == vertex_point:
                    exp = str(feat2['ProfuPVMon'])
                    expressao = QgsExpression(exp)
                    contexto = QgsExpressionContext()
                    contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layerP))
                    with edit (layerP):
                        contexto.setFeature(feat1)
                        feat1['ProfMaxPV'] = expressao.evaluate(contexto)
                        layerP.updateFeature(feat1)
                    exp = '1'
                    expressao = QgsExpression(exp)
                    contexto = QgsExpressionContext()
                    contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layerP))
                    with edit (layerP):
                        contexto.setFeature(feat1)
                        feat1['NumTubos'] = expressao.evaluate(contexto)
                        layerP.updateFeature(feat1)
                elif feat1['Tipo'] == 'PV' and vertex_F2 == vertex_point or feat1['Tipo'] == 'EE' and vertex_F2 == vertex_point:
                    contRede += 1
                    if feat2['aux01'] == 1:
                        auxCont = 1
                    if feat2['TuboQueda'] > 0:
                        exp = '1'
                        expressao = QgsExpression(exp)
                        contexto = QgsExpressionContext()
                        contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layerP))
                        with edit (layerP):
                            contexto.setFeature(feat1)
                            feat1['TuboQueda'] = expressao.evaluate(contexto)
                            layerP.updateFeature(feat1)
                    if feat2['ProfuPVJus'] > feat1['ProfMaxPV']:
                        exp = str(feat2['ProfuPVJus'])
                        expressao = QgsExpression(exp)
                        contexto = QgsExpressionContext()
                        contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layerP))
                        with edit (layerP):
                            contexto.setFeature(feat1)
                            feat1['ProfMaxPV'] = expressao.evaluate(contexto)
                            layerP.updateFeature(feat1)
            if auxCont == 0:
                contRede += 1
            exp = str(contRede)
            expressao = QgsExpression(exp)
            contexto = QgsExpressionContext()
            contexto.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layerP))
            with edit (layerP):
                contexto.setFeature(feat1)
                feat1['NumTubos'] = expressao.evaluate(contexto)
                layerP.updateFeature(feat1)

    def atribuirNome(self):
        from PyQt5.QtCore import QVariant
        from qgis.utils import iface
        from qgis.core import QgsProject, QgsDefaultValue

        def mensagem(mensagem):
            iface.messageBar().pushMessage("Red_Dim_Esg", mensagem, level=Qgis.Success)

        # Camada
        nomecamadaL = self.dlg.comboBoxLinha.currentText()
        nomecamadaP = f'{nomecamadaL}_pontos'
        layerP = QgsProject.instance().mapLayersByName(nomecamadaP)[0]
        layerL = QgsProject.instance().mapLayersByName(nomecamadaL)[0]

        for feat1 in layerL.getFeatures():
            geom1 = feat1.geometry()
            vertex_I = geom1.get()[0][0]
            vertex_F = geom1.get()[0][-1]
            for feat2 in layerP.getFeatures():
                geom2 = feat2.geometry()
                vertex_point = geom2.get()
                if vertex_point == vertex_I:
                    nomeIni = str(feat2['Nome'])
                elif vertex_point == vertex_F:
                    nomeFim = str(feat2['Nome'])
            field_idx = layerL.fields().indexOf('NomeTrecho')
            new_value = nomeIni + ' ~ ' + nomeFim
            with edit(layerL):
                layerL.changeAttributeValue(feat1.id(), field_idx, new_value)

        mensagem('Atribuição de nome finalizada!')

    def run(self):
        """Run method that performs all the real work"""

        # Create the dialog with elements (after translation) and keep reference
        # Only create GUI ONCE in callback, so that it will only load when the plugin is started
        if self.first_start == True:
            self.first_start = False
            self.dlg = DimRedEsgDialog()

        # show the dialog
        self.dlg.show()
        
        # adicionando as funções criadas
        self.carregaVetor()
        self.carregaRaster()
        self.vetorEnt()
        self.rasterEnt()
        
        # Se o botão 'Sentido' for apertado, o aux01 da camada vetorial é corrigido
        self.dlg.buttonBoxSentido.clicked.connect(self.corrigirSentido)
        self.dlg.buttonBoxSentido.clicked.connect(self.conectividade)
        
        # Se o botão 'Aplicar' for apertado, a camada vetorial é preparada
        self.dlg.buttonBoxCampos.clicked.connect(self.criarCampos)
        self.dlg.buttonBoxCampos.clicked.connect(self.carregarEstilos)
        self.dlg.buttonBoxCampos.clicked.connect(self.padraoInicialCampos)

        # Se o botão 'OK' for apertado, o dimensionamento é calculado
        self.dlg.buttonBoxDimens_2.clicked.connect(self.padraoInicialCampos2)
        self.dlg.buttonBoxDimens_2.clicked.connect(self.identificarPS2)
        self.dlg.buttonBoxDimens_2.clicked.connect(self.atribuirVazoes)
        self.dlg.buttonBoxDimens_2.clicked.connect(self.DecMinima)
        self.dlg.buttonBoxDimens_2.clicked.connect(self.DecProfRedes)
        self.dlg.buttonBoxDimens_2.clicked.connect(self.ProfPV)
        self.dlg.buttonBoxDimens_2.clicked.connect(self.tuboQueda)

        # Se o botão 'OK' for apertado, o dimensionamento é calculado
        self.dlg.buttonBoxDimens.clicked.connect(self.padraoInicialCampos2)
        self.dlg.buttonBoxDimens.clicked.connect(self.identificarPS2)
        self.dlg.buttonBoxDimens.clicked.connect(self.atribuirVazoes)
        self.dlg.buttonBoxDimens.clicked.connect(self.DecMinima)
        self.dlg.buttonBoxDimens.clicked.connect(self.DecProfRedes)
        self.dlg.buttonBoxDimens.clicked.connect(self.ProfPV)
        self.dlg.buttonBoxDimens.clicked.connect(self.tuboQueda)
        self.dlg.buttonBoxDimens.clicked.connect(self.indicadores)

        # Depois explico essa pea <-----------------------------
        self.dlg.buttonBoxCriarPV.clicked.connect(self.CriarPV)
        self.dlg.buttonBoxCriarPV.clicked.connect(self.calc_PV)
        self.dlg.buttonBoxCriarPV.clicked.connect(self.carregarEstilos1)

        # Depois explico essa pea <-----------------------------
        self.dlg.buttonBoxNomes.clicked.connect(self.atribuirNome)

        # Abre o manual do plugin
        self.dlg.pushButtonDoc.clicked.connect(self.abrirPDF)
        
        # Run the dialog event loop
        result = self.dlg.exec_()
        
        # See if OK was pressed
        if result:
            # Do something useful here - delete the line containing pass and
            # substitute with your code.

            pass